{"version":3,"sources":["../../src/libs/is-picture-in-picture-disabled.ts","../../src/libs/is-picture-in-picture-supported.ts","../../src/index.ts","CodeBlock.tsx","App.tsx","index.tsx"],"names":["isPictureInPictureDisabled","video","isWebkitPictureInPictureSupported","isPictureInPictureSupported","document","a","onRequestPictureInPictureError","console","isActive","onExitPictureInPictureError","videoRef","options","useState","useEffect","handlePictureInPicture","checkAvailability","setIsPictureInPictureAvailable","onEnterPictureInPicture","onLeavePictureInPicture","isPictureInPictureActive","isPictureInPictureAvailable","togglePictureInPicture","prefersColorScheme","window","matchMedia","CodeBlock","language","value","matches","scheme","setScheme","schemeHandler","event","nextScheme","style","vscDarkPlus","prism","addEventListener","addListener","saveMarkdown","fetch","process","response","text","App","useRef","usePictureInPicture","e","log","markdown","setMarkdown","fetchMarkdown","className","href","media","srcSet","src","alt","size","ref","autoPlay","muted","controls","loop","width","role","aria-label","onClick","source","renderers","code","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.d61e443b.chunk.js","sourcesContent":["import { ExtendedHTMLVideoElement } from '../types'\n\nexport default function isPictureInPictureDisabled(\n  video: ExtendedHTMLVideoElement\n): boolean {\n  return video.disablePictureInPicture\n}\n","import { ExtendedDocument, ExtendedHTMLVideoElement } from '../types'\n\n/**\n * For safari^9.0 support\n */\nexport function isWebkitPictureInPictureSupported(\n  video: ExtendedHTMLVideoElement\n): boolean {\n  return (\n    (video as any).webkitSupportsPresentationMode &&\n    typeof (video as any).webkitSetPresentationMode === 'function'\n  )\n}\nexport default function isPictureInPictureSupported(): boolean {\n  return (document as ExtendedDocument).pictureInPictureEnabled\n}\n","import { useEffect, useState } from 'react'\nimport isPictureInPictureDisabled from './libs/is-picture-in-picture-disabled'\nimport isPictureInPictureSupported, {\n  isWebkitPictureInPictureSupported,\n} from './libs/is-picture-in-picture-supported'\nimport {\n  ExtendedDocument,\n  ExtendedHTMLVideoElement,\n  usePictureInPictureOptions,\n  usePictureInPictureReturnType,\n  VideoRefType,\n} from './types'\n\nexport default function usePictureInPicture(\n  videoRef: VideoRefType,\n  options?: usePictureInPictureOptions\n): usePictureInPictureReturnType {\n  const {\n    onEnterPictureInPicture,\n    onLeavePictureInPicture,\n    onRequestPictureInPictureError,\n    onExitPictureInPictureError,\n  } = options || {}\n\n  const [isPictureInPictureActive, togglePictureInPicture] = useState<boolean>(\n    false\n  )\n\n  const [\n    isPictureInPictureAvailable,\n    setIsPictureInPictureAvailable,\n  ] = useState<boolean>(false)\n\n  useEffect(() => {\n    handlePictureInPicture(\n      videoRef,\n      isPictureInPictureActive,\n      onRequestPictureInPictureError,\n      onExitPictureInPictureError\n    )\n  }, [\n    videoRef,\n    isPictureInPictureActive,\n    onRequestPictureInPictureError,\n    onExitPictureInPictureError,\n  ])\n\n  useEffect(() => {\n    checkAvailability(videoRef.current)\n\n    if (videoRef.current === null) {\n      return\n    }\n    setIsPictureInPictureAvailable(\n      (isWebkitPictureInPictureSupported(videoRef.current) ||\n        isPictureInPictureSupported()) &&\n        !isPictureInPictureDisabled(videoRef.current)\n    )\n\n    if (\n      onEnterPictureInPicture &&\n      typeof onEnterPictureInPicture === 'function'\n    ) {\n      videoRef.current.addEventListener(\n        'enterpictureinpicture',\n        onEnterPictureInPicture\n      )\n    }\n    if (\n      onLeavePictureInPicture &&\n      typeof onLeavePictureInPicture === 'function'\n    ) {\n      videoRef.current.addEventListener(\n        'leavepictureinpicture',\n        onLeavePictureInPicture\n      )\n    }\n\n    return () => {\n      if (videoRef.current === null) {\n        return\n      }\n      if (\n        onEnterPictureInPicture &&\n        typeof onEnterPictureInPicture === 'function'\n      ) {\n        videoRef.current.removeEventListener(\n          'enterpictureinpicture',\n          onEnterPictureInPicture\n        )\n      }\n      if (\n        onLeavePictureInPicture &&\n        typeof onLeavePictureInPicture === 'function'\n      ) {\n        videoRef.current.removeEventListener(\n          'leavepictureinpicture',\n          onLeavePictureInPicture\n        )\n      }\n    }\n  }, [])\n\n  return {\n    isPictureInPictureActive,\n    isPictureInPictureAvailable,\n    togglePictureInPicture,\n  }\n}\n\nfunction checkAvailability(video: ExtendedHTMLVideoElement | null) {\n  /**\n   * As of now, picutre in picture is only available for \"video\" element.\n   */\n  if (video === null) {\n    console.warn(\n      'vieoRef is not referencing to an element. Please pass the videoRef as ref in a video element.'\n    )\n  }\n  if (video && video.nodeName.toLocaleLowerCase() !== 'video') {\n    console.warn(\n      `videoRef is currently referencing to a ${video.nodeName} element. Plese pass it as ref in a video element.`\n    )\n  }\n  /**\n   * Safari^9.0 has a none-standard pip api. \"isWebkitPictureInPictureSupported\" is to support Safari.\n   */\n  if (\n    video &&\n    !isPictureInPictureSupported() &&\n    !isWebkitPictureInPictureSupported(video)\n  ) {\n    console.warn('Picture in picture is not supported in your browser.')\n  }\n  if (video && isPictureInPictureDisabled(video)) {\n    console.warn(\n      'Picture in picture is disabled in your browser. If you want to activate the feature, please enable it in the browser settings.'\n    )\n  }\n  if (video && isWebkitPictureInPictureSupported(video)) {\n    console.warn(\n      'Your browser supports a none-standard Picture in picture API.'\n    )\n  }\n}\n\nasync function handlePictureInPicture(\n  video: VideoRefType,\n  isActive: boolean,\n  onRequestPictureInPictureError: usePictureInPictureOptions['onRequestPictureInPictureError'],\n  onExitPictureInPictureError: usePictureInPictureOptions['onExitPictureInPictureError']\n): Promise<void> {\n  if (video.current === null) {\n    return\n  }\n  if (isActive) {\n    try {\n      if (isWebkitPictureInPictureSupported(video.current)) {\n        // Safari^9.0 support\n        ;(video.current as any).webkitSetPresentationMode('picture-in-picture')\n      } else {\n        await video.current.requestPictureInPicture()\n      }\n    } catch (error) {\n      if (\n        onRequestPictureInPictureError &&\n        typeof onRequestPictureInPictureError === 'function'\n      ) {\n        onRequestPictureInPictureError(error)\n      }\n      console.error('Video failed to enter Picture-in-Picture mode.')\n    }\n  }\n  if (!isActive && (document as ExtendedDocument).pictureInPictureElement) {\n    try {\n      if (isWebkitPictureInPictureSupported(video.current)) {\n        // Safari^9.0 support\n        ;(video.current as any).webkitSetPresentationMode('inline')\n      } else {\n        await (document as ExtendedDocument).exitPictureInPicture()\n      }\n    } catch (error) {\n      if (\n        onExitPictureInPictureError &&\n        typeof onExitPictureInPictureError === 'function'\n      ) {\n        onExitPictureInPictureError(error)\n      }\n      console.error('Video failed to leave Picture-in-Picture mode.')\n    }\n  }\n}\n","import React, { useEffect, useState } from 'react'\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'\nimport {\n  prism,\n  vscDarkPlus,\n} from 'react-syntax-highlighter/dist/esm/styles/prism'\n\nconst prefersColorScheme = window.matchMedia('(prefers-color-scheme: dark)')\n\ninterface CodeBlockProps {\n  language?: string\n  value: string\n}\n\nconst CodeBlock: React.FC<CodeBlockProps> = ({ language, value }) => {\n  const [scheme, setScheme] = useState<'dark' | 'light'>(\n    prefersColorScheme.matches ? 'dark' : 'light'\n  )\n  const schemeHandler = (event: MediaQueryListEvent) => {\n    const nextScheme = event.matches ? 'dark' : 'light'\n    setScheme(nextScheme)\n  }\n  const style = scheme === 'dark' ? vscDarkPlus : prism\n\n  useEffect(() => {\n    if (prefersColorScheme.addEventListener) {\n      prefersColorScheme.addEventListener('change', schemeHandler)\n    } else {\n      prefersColorScheme.addListener(schemeHandler)\n    }\n  }, [])\n\n  return (\n    <SyntaxHighlighter language={language} style={style}>\n      {value}\n    </SyntaxHighlighter>\n  )\n}\n\nexport default CodeBlock\n","import React, {\n  Dispatch,\n  SetStateAction,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport ReactMarkdown from 'react-markdown'\nimport usePictureInPicture from 'react-use-pip'\nimport CodeBlock from './CodeBlock'\nimport { VscGithubInverted } from 'react-icons/vsc'\nimport './app.css'\nimport { ExtendedHTMLVideoElement } from '../../dist/types'\n\nasync function fetchMarkdown(\n  saveMarkdown: Dispatch<SetStateAction<string | undefined>>\n): Promise<void> {\n  const response = await fetch(`${process.env.PUBLIC_URL}/DOC.md`)\n  const text = await response.text()\n  saveMarkdown(text)\n}\n\nconst App = () => {\n  const videoRef = useRef<ExtendedHTMLVideoElement | null>(null)\n  const {\n    isPictureInPictureActive,\n    isPictureInPictureAvailable,\n    togglePictureInPicture,\n  } = usePictureInPicture(videoRef, {\n    onEnterPictureInPicture: (e) => console.log('enter picture in picture', e),\n    onLeavePictureInPicture: (e) => console.log('leave picture in picture', e),\n  })\n  const handleClick = () => togglePictureInPicture(!isPictureInPictureActive)\n  const [markdown, setMarkdown] = useState<string>()\n\n  useEffect(() => {\n    fetchMarkdown(setMarkdown)\n  }, [])\n\n  return (\n    <>\n      <nav className=\"nav\">\n        <a href={process.env.PUBLIC_URL}>\n          <picture className=\"picture\">\n            <source\n              media=\"(prefers-color-scheme: dark)\"\n              srcSet={`${process.env.PUBLIC_URL}/logo-dark-64x64.png`}\n            />\n            <img\n              className=\"logo\"\n              src={`${process.env.PUBLIC_URL}/logo-light-64x64.png`}\n              alt=\"react-use-pip-logo\"\n            />\n          </picture>\n        </a>\n        <a href={process.env.PUBLIC_URL} className=\"title\">\n          <h3>react-use-pip</h3>\n        </a>\n        <div className=\"tools\"></div>\n        <a\n          href=\"https://github.com/DawChihLiou/react-use-pip\"\n          className=\"icon-link\"\n        >\n          <VscGithubInverted size={24} />\n        </a>\n      </nav>\n      <div className=\"app\">\n        <video ref={videoRef} autoPlay muted controls loop width=\"100%\">\n          <source src=\"video-sample.mp4\" />\n        </video>\n        <h3>\n          Try the React Hook yourself\n          <span role=\"img\" aria-label=\"emoji pointing down\">\n            ðŸ‘‡\n          </span>\n        </h3>\n        <div className=\"action-row\">\n          {isPictureInPictureAvailable && (\n            <button onClick={handleClick} className=\"control-button\">\n              {isPictureInPictureActive ? 'Exit' : 'Enter'} Picture in Picture\n            </button>\n          )}\n          {!isPictureInPictureAvailable && (\n            <p>\n              Picture in Picture feature API is not available in your browser.\n            </p>\n          )}\n        </div>\n        <ReactMarkdown source={markdown} renderers={{ code: CodeBlock }} />\n      </div>\n    </>\n  )\n}\n\nexport default App\n","import 'normalize.css'\nimport './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}